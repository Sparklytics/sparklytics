use std::sync::Arc;

use axum::{
    body::Body,
    extract::{DefaultBodyLimit, Request, State},
    http::{header::CONTENT_TYPE, HeaderValue, Method, StatusCode, Uri},
    middleware::{self, Next},
    response::{IntoResponse, Response},
    routing::{get, post, put},
    Router,
};
use include_dir::{include_dir, Dir};
use tower_http::{
    cors::{AllowOrigin, Any, CorsLayer},
    trace::TraceLayer,
};

use sparklytics_core::config::AuthMode;

use crate::{auth, routes, state::AppState};

/// Embedded static dashboard files (generated by `cd dashboard && npm run build`).
/// If the build directory is absent, build.rs creates a placeholder index.html.
static DASHBOARD: Dir<'static> = include_dir!("$CARGO_MANIFEST_DIR/../../dashboard/out");

/// Map a file extension to a MIME type string.
fn mime_for_path(path: &str) -> &'static str {
    match path.rsplit('.').next().unwrap_or("") {
        "html" => "text/html; charset=utf-8",
        "js" | "mjs" => "application/javascript",
        "css" => "text/css",
        "json" => "application/json",
        "svg" => "image/svg+xml",
        "png" => "image/png",
        "jpg" | "jpeg" => "image/jpeg",
        "ico" => "image/x-icon",
        "woff" => "font/woff",
        "woff2" => "font/woff2",
        "ttf" => "font/ttf",
        "txt" => "text/plain",
        _ => "application/octet-stream",
    }
}

fn auth_mode_runtime_value(auth_mode: &AuthMode) -> &'static str {
    match auth_mode {
        AuthMode::None => "none",
        AuthMode::Password(_) => "password",
        AuthMode::Local => "local",
    }
}

fn inject_runtime_auth_mode(html: &[u8], auth_mode: &AuthMode) -> Vec<u8> {
    let Ok(mut rendered) = String::from_utf8(html.to_vec()) else {
        return html.to_vec();
    };

    let script = format!(
        "<script>window.__SPARKLYTICS_AUTH_MODE__='{}';</script>",
        auth_mode_runtime_value(auth_mode)
    );

    if rendered.contains("window.__SPARKLYTICS_AUTH_MODE__") {
        return rendered.into_bytes();
    }

    if let Some(idx) = rendered.find("</head>") {
        rendered.insert_str(idx, &script);
        return rendered.into_bytes();
    }

    if let Some(idx) = rendered.find("</body>") {
        rendered.insert_str(idx, &script);
        return rendered.into_bytes();
    }

    format!("{script}{rendered}").into_bytes()
}

/// Fallback handler: serve embedded dashboard static files.
///
/// API and health paths that don't match a registered route return 404 rather
/// than the SPA shell so clients receive a proper error response.
///
/// Resolution order for other paths:
/// 1. Exact file match (e.g. `/_next/static/js/main.js`)
/// 2. `{path}/index.html` (for directory-style paths with trailing slash)
/// 3. `index.html` — SPA catch-all so client-side routing works
async fn serve_dashboard(State(state): State<Arc<AppState>>, uri: Uri) -> Response {
    let path = uri.path();

    // Don't swallow unregistered /api/* or /health requests — return 404.
    if path.starts_with("/api/") || path == "/health" {
        return StatusCode::NOT_FOUND.into_response();
    }

    let raw_path = path.trim_start_matches('/');

    // Build lookup candidates in priority order:
    //   1. Exact file match
    //   2. Directory-style index (path/index.html)
    //   3. Parent-directory index (e.g. /share/abc123 → share/index.html)
    //      Allows client-side routing on pages like /share/<shareId>
    //   4. Root SPA shell (index.html)
    let candidates: Vec<String> = if raw_path.is_empty() {
        vec!["index.html".to_string()]
    } else if raw_path.ends_with('/') {
        vec![format!("{}index.html", raw_path), "index.html".to_string()]
    } else {
        let mut v = vec![raw_path.to_string(), format!("{}/index.html", raw_path)];
        // parent directory index — e.g. "share/abc123" → "share/index.html"
        if let Some(parent) = raw_path.rfind('/').map(|i| &raw_path[..i]) {
            if !parent.is_empty() {
                v.push(format!("{}/index.html", parent));
            }
        }
        v.push("index.html".to_string());
        v
    };

    for candidate in &candidates {
        if let Some(file) = DASHBOARD.get_file(candidate.as_str()) {
            let mime = mime_for_path(candidate);
            let body = if mime.starts_with("text/html") {
                inject_runtime_auth_mode(file.contents(), &state.config.auth_mode)
            } else {
                file.contents().to_vec()
            };
            match Response::builder()
                .header(CONTENT_TYPE, mime)
                .body(Body::from(body))
            {
                Ok(resp) => return resp,
                Err(_) => return StatusCode::INTERNAL_SERVER_ERROR.into_response(),
            }
        }
    }

    StatusCode::NOT_FOUND.into_response()
}

/// Build the CORS layer for analytics query + auth routes.
///
/// If `SPARKLYTICS_CORS_ORIGINS` is set, only those origins are allowed.
/// If it's empty, no cross-origin requests are allowed at all (same-origin only).
fn restricted_cors(origins: &[String]) -> CorsLayer {
    if origins.is_empty() {
        // No allowed origins configured — block all cross-origin requests.
        CorsLayer::new()
            .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])
            .allow_headers(Any)
    } else {
        let parsed: Vec<HeaderValue> = origins
            .iter()
            .filter_map(|o| o.parse::<HeaderValue>().ok())
            .collect();
        CorsLayer::new()
            .allow_origin(AllowOrigin::list(parsed))
            .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])
            .allow_headers(Any)
    }
}

/// Construct the Axum [`Router`] with all routes and middleware attached.
pub fn build_app(state: Arc<AppState>) -> Router {
    let auth_mode = state.config.auth_mode.clone();

    // CORS: /api/collect allows any origin; analytics/auth routes enforce allowlist.
    let collect_cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods([Method::POST, Method::OPTIONS])
        .allow_headers(Any);
    let query_cors = restricted_cors(&state.config.cors_origins);

    // /api/collect in its own sub-router so layer() type inference works cleanly.
    let collect_router = Router::new()
        .route("/api/collect", post(routes::collect::collect))
        .layer(collect_cors)
        .layer(DefaultBodyLimit::max(routes::collect::COLLECT_BODY_LIMIT));

    // Public share routes — no auth, no CORS restriction, 30 req/min rate limit.
    let share_router = Router::new()
        .route(
            "/api/share/{share_id}/overview",
            get(routes::share::share_overview),
        )
        .route(
            "/api/share/{share_id}/stats",
            get(routes::share::share_stats),
        )
        .route(
            "/api/share/{share_id}/pageviews",
            get(routes::share::share_pageviews),
        )
        .route(
            "/api/share/{share_id}/metrics",
            get(routes::share::share_metrics),
        );
    let acquisition_public_router = Router::new()
        .route("/l/{slug}", get(routes::links::track_link_redirect))
        .route("/p/{pixel_key}", get(routes::pixels::track_pixel));

    // Always-public routes.
    let mut app = Router::new()
        .route("/health", get(routes::health::health))
        .merge(collect_router)
        .merge(share_router)
        .merge(acquisition_public_router);

    match auth_mode {
        AuthMode::None => {
            // No auth: all routes open, no auth endpoints.
            // Apply query_cors to the analytics sub-router.
            let analytics = Router::new()
                .route("/api/websites", post(routes::websites::create_website))
                .route("/api/websites", get(routes::websites::list_websites))
                .route(
                    "/api/websites/{id}",
                    get(routes::websites::get_website)
                        .put(routes::websites::update_website)
                        .delete(routes::websites::delete_website),
                )
                .route("/api/websites/{id}/stats", get(routes::stats::get_stats))
                .route(
                    "/api/websites/{id}/events",
                    get(routes::events::get_event_names),
                )
                .route(
                    "/api/websites/{id}/events/properties",
                    get(routes::events::get_event_properties),
                )
                .route(
                    "/api/websites/{id}/events/timeseries",
                    get(routes::events::get_event_timeseries),
                )
                .route(
                    "/api/websites/{id}/sessions",
                    get(routes::sessions::list_sessions),
                )
                .route(
                    "/api/websites/{id}/sessions/{session_id}",
                    get(routes::sessions::get_session),
                )
                .route("/api/websites/{id}/goals", get(routes::goals::list_goals))
                .route("/api/websites/{id}/goals", post(routes::goals::create_goal))
                .route(
                    "/api/websites/{id}/goals/{goal_id}",
                    put(routes::goals::update_goal).delete(routes::goals::delete_goal),
                )
                .route(
                    "/api/websites/{id}/goals/{goal_id}/stats",
                    get(routes::goals::get_goal_stats),
                )
                .route(
                    "/api/websites/{id}/attribution",
                    get(routes::attribution::get_attribution),
                )
                .route(
                    "/api/websites/{id}/revenue/summary",
                    get(routes::attribution::get_revenue_summary),
                )
                .route(
                    "/api/websites/{id}/funnels",
                    get(routes::funnels::list_funnels),
                )
                .route(
                    "/api/websites/{id}/funnels",
                    post(routes::funnels::create_funnel),
                )
                .route(
                    "/api/websites/{id}/funnels/{funnel_id}",
                    get(routes::funnels::get_funnel)
                        .put(routes::funnels::update_funnel)
                        .delete(routes::funnels::delete_funnel),
                )
                .route(
                    "/api/websites/{id}/funnels/{funnel_id}/results",
                    get(routes::funnels::get_funnel_results),
                )
                .route(
                    "/api/websites/{id}/journey",
                    get(routes::journey::get_journey),
                )
                .route(
                    "/api/websites/{id}/retention",
                    get(routes::retention::get_retention),
                )
                .route(
                    "/api/websites/{id}/reports",
                    get(routes::reports::list_reports).post(routes::reports::create_report),
                )
                .route(
                    "/api/websites/{id}/reports/preview",
                    post(routes::reports::preview_report),
                )
                .route(
                    "/api/websites/{id}/reports/{report_id}",
                    get(routes::reports::get_report)
                        .put(routes::reports::update_report)
                        .delete(routes::reports::delete_report),
                )
                .route(
                    "/api/websites/{id}/reports/{report_id}/run",
                    post(routes::reports::run_report),
                )
                .route(
                    "/api/websites/{id}/links",
                    get(routes::links::list_links).post(routes::links::create_link),
                )
                .route(
                    "/api/websites/{id}/links/{link_id}",
                    put(routes::links::update_link).delete(routes::links::delete_link),
                )
                .route(
                    "/api/websites/{id}/links/{link_id}/stats",
                    get(routes::links::get_link_stats),
                )
                .route(
                    "/api/websites/{id}/pixels",
                    get(routes::pixels::list_pixels).post(routes::pixels::create_pixel),
                )
                .route(
                    "/api/websites/{id}/pixels/{pixel_id}",
                    put(routes::pixels::update_pixel).delete(routes::pixels::delete_pixel),
                )
                .route(
                    "/api/websites/{id}/pixels/{pixel_id}/stats",
                    get(routes::pixels::get_pixel_stats),
                )
                .route(
                    "/api/websites/{id}/pageviews",
                    get(routes::pageviews::get_pageviews),
                )
                .route(
                    "/api/websites/{id}/metrics",
                    get(routes::metrics::get_metrics),
                )
                .route(
                    "/api/websites/{id}/realtime",
                    get(routes::realtime::get_realtime),
                )
                .route(
                    "/api/websites/{id}/share",
                    post(routes::share::enable_sharing).delete(routes::share::disable_sharing),
                )
                .route(
                    "/api/websites/{id}/export",
                    get(routes::export::export_events),
                )
                .route("/api/usage", get(routes::export::usage_not_found))
                .layer(query_cors);
            app = app.merge(analytics);
        }
        _ => {
            // Public auth routes (no CORS — dashboard same-origin only).
            app = app
                .route("/api/auth/status", get(auth::handlers::auth_status))
                .route("/api/auth/setup", post(auth::handlers::auth_setup))
                .route("/api/auth/login", post(auth::handlers::auth_login));

            // Protected routes (cookie or API key) — enforce CORS origins.
            let auth_state = Arc::clone(&state);
            let protected = Router::new()
                .route("/api/websites", post(routes::websites::create_website))
                .route("/api/websites", get(routes::websites::list_websites))
                .route(
                    "/api/websites/{id}",
                    get(routes::websites::get_website)
                        .put(routes::websites::update_website)
                        .delete(routes::websites::delete_website),
                )
                .route("/api/websites/{id}/stats", get(routes::stats::get_stats))
                .route(
                    "/api/websites/{id}/events",
                    get(routes::events::get_event_names),
                )
                .route(
                    "/api/websites/{id}/events/properties",
                    get(routes::events::get_event_properties),
                )
                .route(
                    "/api/websites/{id}/events/timeseries",
                    get(routes::events::get_event_timeseries),
                )
                .route(
                    "/api/websites/{id}/sessions",
                    get(routes::sessions::list_sessions),
                )
                .route(
                    "/api/websites/{id}/sessions/{session_id}",
                    get(routes::sessions::get_session),
                )
                .route("/api/websites/{id}/goals", get(routes::goals::list_goals))
                .route("/api/websites/{id}/goals", post(routes::goals::create_goal))
                .route(
                    "/api/websites/{id}/goals/{goal_id}",
                    put(routes::goals::update_goal).delete(routes::goals::delete_goal),
                )
                .route(
                    "/api/websites/{id}/goals/{goal_id}/stats",
                    get(routes::goals::get_goal_stats),
                )
                .route(
                    "/api/websites/{id}/attribution",
                    get(routes::attribution::get_attribution),
                )
                .route(
                    "/api/websites/{id}/revenue/summary",
                    get(routes::attribution::get_revenue_summary),
                )
                .route(
                    "/api/websites/{id}/funnels",
                    get(routes::funnels::list_funnels),
                )
                .route(
                    "/api/websites/{id}/funnels",
                    post(routes::funnels::create_funnel),
                )
                .route(
                    "/api/websites/{id}/funnels/{funnel_id}",
                    get(routes::funnels::get_funnel)
                        .put(routes::funnels::update_funnel)
                        .delete(routes::funnels::delete_funnel),
                )
                .route(
                    "/api/websites/{id}/funnels/{funnel_id}/results",
                    get(routes::funnels::get_funnel_results),
                )
                .route(
                    "/api/websites/{id}/journey",
                    get(routes::journey::get_journey),
                )
                .route(
                    "/api/websites/{id}/retention",
                    get(routes::retention::get_retention),
                )
                .route(
                    "/api/websites/{id}/reports",
                    get(routes::reports::list_reports).post(routes::reports::create_report),
                )
                .route(
                    "/api/websites/{id}/reports/preview",
                    post(routes::reports::preview_report),
                )
                .route(
                    "/api/websites/{id}/reports/{report_id}",
                    get(routes::reports::get_report)
                        .put(routes::reports::update_report)
                        .delete(routes::reports::delete_report),
                )
                .route(
                    "/api/websites/{id}/reports/{report_id}/run",
                    post(routes::reports::run_report),
                )
                .route(
                    "/api/websites/{id}/links",
                    get(routes::links::list_links).post(routes::links::create_link),
                )
                .route(
                    "/api/websites/{id}/links/{link_id}",
                    put(routes::links::update_link).delete(routes::links::delete_link),
                )
                .route(
                    "/api/websites/{id}/links/{link_id}/stats",
                    get(routes::links::get_link_stats),
                )
                .route(
                    "/api/websites/{id}/pixels",
                    get(routes::pixels::list_pixels).post(routes::pixels::create_pixel),
                )
                .route(
                    "/api/websites/{id}/pixels/{pixel_id}",
                    put(routes::pixels::update_pixel).delete(routes::pixels::delete_pixel),
                )
                .route(
                    "/api/websites/{id}/pixels/{pixel_id}/stats",
                    get(routes::pixels::get_pixel_stats),
                )
                .route(
                    "/api/websites/{id}/pageviews",
                    get(routes::pageviews::get_pageviews),
                )
                .route(
                    "/api/websites/{id}/metrics",
                    get(routes::metrics::get_metrics),
                )
                .route(
                    "/api/websites/{id}/realtime",
                    get(routes::realtime::get_realtime),
                )
                .route(
                    "/api/websites/{id}/share",
                    post(routes::share::enable_sharing).delete(routes::share::disable_sharing),
                )
                .route(
                    "/api/websites/{id}/export",
                    get(routes::export::export_events),
                )
                .route("/api/usage", get(routes::export::usage_not_found))
                .layer(query_cors)
                .layer(middleware::from_fn(move |req: Request, next: Next| {
                    let s = auth_state.clone();
                    async move { auth::middleware::require_auth(s, req, next).await }
                }));

            // Cookie-only routes (auth management — same-origin, no CORS needed).
            let cookie_state = Arc::clone(&state);
            let cookie_only = Router::new()
                .route("/api/auth/logout", post(auth::handlers::auth_logout))
                .route("/api/auth/session", get(auth::handlers::auth_session))
                .route(
                    "/api/auth/password",
                    put(auth::handlers::auth_change_password),
                )
                .route("/api/auth/keys", get(auth::handlers::list_api_keys))
                .route(
                    "/api/auth/keys",
                    post(auth::handlers::create_api_key_handler),
                )
                .route(
                    "/api/auth/keys/{id}",
                    axum::routing::delete(auth::handlers::delete_api_key),
                )
                .layer(middleware::from_fn(move |req: Request, next: Next| {
                    let s = cookie_state.clone();
                    async move { auth::middleware::require_cookie_auth(s, req, next).await }
                }));

            app = app.merge(protected).merge(cookie_only);
        }
    }

    app.fallback(serve_dashboard)
        .layer(TraceLayer::new_for_http())
        .with_state(state)
}
